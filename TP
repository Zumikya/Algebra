type Conjunto a = [a]
type Fila = [Integer]
type Tablero = [Fila]
type Posicion = (Integer,Integer)
type Camino = [Posicion]

sopa1 :: Tablero
sopa1 = [[13,12,6,4],[1,1,32,25],[9,2,16,8],[7,3,5,4],[1,2,8,2]]

sopa2 :: Tablero
sopa2 = [[64,5,16,8,9],[32,16,8,4,28],[2,1,4,6,3],[8,4,2,1,10]]

sopa3 :: Tablero
sopa3 = [[10,5,7,9],[32,16,22,28],[8,4,11,34],[12,6,10,17]]

sopa4 :: Tablero
sopa4 = [[1,1,2,1], [1,8,4,1], [10,1,1,1], [5,16,1,1]]

camino1 :: Camino 
camino1 = [(3,3),(3,4),(4,4)]

camino2 :: Camino 
camino2 = [(1,2),(2,2),(2,3),(3,3),(4,3)]

camino3 :: Camino 
camino3 = [(1,3),(2,3),(3,3),(3,4)]

camino4 :: Camino
camino4 = [(4,1),(4,2),(4,3)]

--EJERCICIO 1

--Dada una fila (lista), devuelve su mayor elemento
maximoFila :: [Integer] -> Integer
maximoFila [x] = x
maximoFila (x:y:xs) 
 | x > y = maximoFila (x:xs)
 | otherwise = maximoFila (y:xs)

--Dado un tablero, devuelve el mayor elemento (comparando el mayor de cada fila)
maximo :: Tablero -> Integer
maximo [x] = maximoFila x 
maximo (x:y:cx)
 | maximoFila x > maximoFila y = maximo (x:cx)
 | otherwise = maximo (y:cx)

--EJERCICIO 3

-- Devuelve el valor de una posicion de un tablero (funciones dadas en el esqueleto)
valor :: Tablero -> Posicion -> Integer
valor (t:ts) (1,y) = valorY t y
valor (t:ts) (x,y) = valor ts (x-1,y)

valorY :: [Integer] -> Integer -> Integer
valorY (c:cs) 1 = c
valorY (c:cs) n = valorY cs (n-1)

{-Dado un tablero y un camino, busca el valor de la primera posicion del camino (el primer elemento) y vuelve a llamar a la funcion
con las demas posiciones del camino (los demas elementos = la tail de camino). Cuando ya no hay mas elementos en el camino, devuelve
la lista vacÃ­a, que une todo en una lista-}
valoresDeCamino :: Tablero -> Camino -> [Integer]
valoresDeCamino t [] = []
valoresDeCamino t (x:xs) = (valor t x):(valoresDeCamino t xs)

--EJERCICIO 4

--Dado un numero, le aplica la sucesion de Collatz
terminoSucCollatz :: Integer -> Integer
terminoSucCollatz n 
 | mod n 2 == 0 = div n 2
 | otherwise = 3*n + 1

{-Dada una lista, determina si sus elementos siguen la sucesion de Collatz (preguntando si el resultado de aplicarle la sucesion al
primer termino devuelve el segundo termino). (*)Si se cumple con el primero y con el segundo(*), vuelve a llamar a la funcion con la tail
de la lista (para ver si se cumple con el segundo y el tercero de la lista inicial). Si nos quedamos con un elemento, la tail es la
lista vacia, y eso significa que funciono para todos los elementos anteriores. Entonces devuelve True. Si esto no se cumple quiere
decir que para algun par de elementos no fue cierto la afirmacion entre (*), entonces devuelve False.-}
esListaDeCollatz :: [Integer] -> Bool
esListaDeCollatz [x] = True
esListaDeCollatz (x:y:xs)
 | y == terminoSucCollatz x = esListaDeCollatz (y:xs) 
 | otherwise = False

{-Dado un tablero, un camino y el numero donde deberia empezar la sucesion, determina si el camino resultante es de Collatz. Primero
nos tenemos que asegurar de que el numero que nos pasan sea el mismo que la primera posicion del camino (el primer elemento). Si eso se
cumple y tambien que la lista que obtenemos de traducir las posiciones a elementos del tablero cumple la sucesion de Collatz, devolvemos
True. Si alguna de las anteriores no se cumple, devolvemos False.-}
caminoDeCollatz :: Tablero -> Camino -> Integer -> Bool
caminoDeCollatz t (c:cs) n 
 | ((valor t c) == n) && (esListaDeCollatz (valoresDeCamino t (c:cs))) = True
 | otherwise = False 
 
--EJERCICIO 2 
 
aplanar :: Tablero -> [Integer]
aplanar [] = []
aplanar t = (head t) ++ (aplanar (tail t))

tuplar :: [Integer] -> [(Integer, Integer)]
tuplar [] = []
tuplar (x:xs) = (x, 1):(tuplar xs)

comprimirPrimero :: [(Integer, Integer)] -> [(Integer, Integer)]
comprimirPrimero [x] = [x]
comprimirPrimero ((x1, y1):(x2,y2):xs) | x1 == x2 = comprimirPrimero ((x1, y1 + y2):xs)
                                       | otherwise = comprimirPrimero ((x1, y1):xs)
                                       
deslistar :: [a] -> a
deslistar [a] = a

quitarTupla :: (Integer, Integer) -> [(Integer, Integer)] -> [(Integer, Integer)]
quitarTupla _ [] = []
quitarTupla n (x:xs)
 | n == x = quitarTupla n xs
 | otherwise = x:(quitarTupla n xs)

comprimir :: [(Integer, Integer)] -> [(Integer, Integer)]
comprimir [] = []
comprimir (x:xs) = (deslistar (comprimirPrimero (x:xs))):(comprimir (quitarTupla x (x:xs)))

masApariciones :: [(Integer, Integer)] -> Integer
masApariciones [(x1, x2)] = x1
masApariciones ((x1, x2):(y1, y2):xs)
 | x2 >= y2 = masApariciones ((x1, x2):xs)
 | otherwise = masApariciones ((y1, y2):xs)
 
masRepetidoLista :: [Integer] -> Integer
masRepetidoLista xs = masApariciones (comprimir (tuplar xs))

masRepetido :: Tablero -> Integer
masRepetido t = masRepetidoLista (aplanar t)

pertenece :: Eq a => a -> [a] -> Bool
pertenece _ [] = False
pertenece a (x:xs) = a == x || pertenece a xs

reemplazar :: Integer -> Integer -> [Integer] -> [Integer]
reemplazar a b (x:xs)
 | a == x = (b:xs)
 | otherwise = x:(reemplazar a b xs)

reemplazarTab :: Integer -> Integer -> Tablero -> Tablero
reemplazarTab _ _ [] = []
reemplazarTab a b (f:fs)
 | pertenece a f = ((reemplazar a b f):fs)
 | otherwise = f:(reemplazarTab a b fs)

buscarColumna :: Fila -> Integer -> Integer
buscarColumna (n:ns) a
 | n == a = 1
 | otherwise = 1 + buscarColumna ns a
 
posicion :: Tablero -> Integer -> (Integer, Integer)
posicion [] _ = (0, 0)
posicion (f:fs) a
 | pertenece a f = (1, buscarColumna f a)
 | otherwise = (1 + (fst (posicion fs a)), (snd (posicion fs a)))
 
perteneceATablero :: Integer -> Tablero -> Bool
perteneceATablero _ [] = False
perteneceATablero n (f:fs)
 | pertenece n f = True
 | otherwise = perteneceATablero n fs

posicionesTablero :: Tablero -> Integer -> [(Integer, Integer)]
posicionesTablero t n 
 | perteneceATablero n t = (posicion t n):(posicionesTablero (reemplazarTab n (-n) t) n)
 | otherwise = []

                                       


